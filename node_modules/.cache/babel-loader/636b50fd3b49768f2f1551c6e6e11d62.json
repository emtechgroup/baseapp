{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar cashaddr = require('cashaddrjs');\n\nvar errors = require('./errors');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Networks = require('./networks');\n\nvar Hash = require('./crypto/hash');\n\nvar JSUtil = require('./util/js');\n\nvar PublicKey = require('./publickey');\n\nvar BITPAY_P2PKH_VERSION_BYTE = 28;\nvar BITPAY_P2SH_VERSION_BYTE = 40;\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\n * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash` and `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\n\nfunction Address(data, network, type) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash) {\n    throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type); // set defaults if not set\n\n\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n  return this;\n}\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\n\n\nAddress.prototype._classifyArguments = function (data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n    return Address._transformHash(data);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof data === 'string') {\n    return Address._transformString(data, network, type, Address.DefaultFormat);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n/** @static */\n\n\nAddress.LegacyFormat = 'legacy';\n/** @static */\n\nAddress.BitpayFormat = 'bitpay';\n/** @static */\n\nAddress.CashAddrFormat = 'cashaddr';\n/** @static */\n\nAddress.DefaultFormat = Address.LegacyFormat;\n/** @static */\n\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\n\nAddress.PayToScriptHash = 'scripthash';\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\n\nAddress._transformHash = function (hash) {\n  var info = {};\n\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (hash.length !== 20) {\n    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n  }\n\n  info.hashBuffer = hash;\n  return info;\n};\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\n\n\nAddress._transformObject = function (data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? new Buffer(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\n\n\nAddress._classifyFromVersion = function (buffer) {\n  var version = {};\n  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n  if (pubkeyhashNetwork) {\n    version.network = pubkeyhashNetwork;\n    version.type = Address.PayToPublicKeyHash;\n  } else if (scripthashNetwork) {\n    version.network = scripthashNetwork;\n    version.type = Address.PayToScriptHash;\n  }\n\n  return version;\n};\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformBuffer = function (buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length !== 1 + 20) {\n    throw new TypeError('Address buffers must be exactly 21 bytes.');\n  }\n\n  network = Networks.get(network);\n\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (!bufferVersion.network || network && network !== bufferVersion.network) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || type && type !== bufferVersion.type) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  info.hashBuffer = buffer.slice(1);\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\n\n\nAddress._transformPublicKey = function (pubkey) {\n  var info = {};\n\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n\n  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  info.type = Address.PayToPublicKeyHash;\n  return info;\n};\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\n\n\nAddress._transformScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n\n  return info;\n};\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @return {Address}\n */\n\n\nAddress.createMultisig = function (publicKeys, threshold, network) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n};\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @param {string} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformString = function (data, network, type, format) {\n  if (typeof data !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  data = data.trim();\n\n  if (format === Address.LegacyFormat) {\n    return Address._transformStringLegacy(data, network, type);\n  } else if (format === Address.BitpayFormat) {\n    return Address._transformStringBitpay(data, network, type);\n  } else if (format === Address.CashAddrFormat) {\n    return Address._transformStringCashAddr(data, network, type);\n  }\n\n  throw new TypeError('Unrecognized address format.');\n};\n/**\n * Internal function to transform a bitcoin address string in legacy format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformStringLegacy = function (data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n/**\n * Internal function to transform a bitcoin address string in Bitpay format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformStringBitpay = function (data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n\n  if (addressBuffer[0] === BITPAY_P2PKH_VERSION_BYTE) {\n    addressBuffer[0] = 0;\n  } else if (addressBuffer[0] === BITPAY_P2SH_VERSION_BYTE) {\n    addressBuffer[0] = 5;\n  }\n\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n/**\n * Internal function to transform a bitcoin address string in CashAddr format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\n\n\nAddress._transformStringCashAddr = function (data, network, type) {\n  if (!(typeof network === 'string')) {\n    network = network.toString();\n  }\n\n  var decoded = cashaddr.decode(data);\n  $.checkArgument(!network || network === 'livenet' && decoded.prefix === 'bitcoincash' || network === 'testnet' && decoded.prefix === 'bchtest', 'Invalid network.');\n  $.checkArgument(!type || type === Address.PayToPublicKeyHash && decoded.type === 'P2PKH' || type === Address.PayToScriptHash && decoded.type === 'P2SH', 'Invalid type.');\n  network = Networks.get(network || (decoded.prefix === 'bitcoincash' ? 'livenet' : 'testnet'));\n  type = type || (decoded.type === 'P2PKH' ? Address.PayToPublicKeyHash : Address.PayToScriptHash);\n  var version = new Buffer([network[type]]);\n  var hashBuffer = new Buffer(decoded.hash);\n  var addressBuffer = Buffer.concat([version, hashBuffer]);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromPublicKey = function (data, network) {\n  var info = Address._transformPublicKey(data);\n\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromPublicKeyHash = function (hash, network) {\n  var info = Address._transformHash(hash);\n\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromScriptHash = function (hash, network) {\n  $.checkArgument(hash, 'hash parameter is required');\n\n  var info = Address._transformHash(hash);\n\n  return new Address(info.hashBuffer, network, Address.PayToScriptHash);\n};\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.payingTo = function (script, network) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n};\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n\n  var info = Address._transformScript(script, network);\n\n  return new Address(info.hashBuffer, network, info.type);\n};\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromBuffer = function (buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Address} A new valid and frozen instance of an Address\n */\n\n\nAddress.fromString = function (str, network, type, format) {\n  format = format || Address.DefaultFormat;\n\n  var info = Address._transformString(str, network, type, format);\n\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\n\n\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(JSUtil.isHexa(obj.hash), 'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.');\n  var hashBuffer = new Buffer(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\n\n\nAddress.getValidationError = function (data, network, type) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\n\n\nAddress.isValid = function (data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToPublicKeyHash = function () {\n  return this.type === Address.PayToPublicKeyHash;\n};\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\n\n\nAddress.prototype.isPayToScriptHash = function () {\n  return this.type === Address.PayToScriptHash;\n};\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\n\n\nAddress.prototype.toBuffer = function () {\n  var version = new Buffer([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n/**\n * @returns {Object} A plain object with the address information\n */\n\n\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n/**\n * Will return a the string representation of the address\n *\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype.toString = function (format) {\n  format = format || Address.DefaultFormat;\n\n  if (format === Address.LegacyFormat) {\n    return this._toStringLegacy();\n  } else if (format === Address.BitpayFormat) {\n    return this._toStringBitpay();\n  } else if (format === Address.CashAddrFormat) {\n    return this._toStringCashAddr();\n  }\n\n  throw new TypeError('Unrecognized address format.');\n};\n/**\n * Will return a the string representation of the address in legacy format\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype._toStringLegacy = function () {\n  return Base58Check.encode(this.toBuffer());\n};\n/**\n * Will return a the string representation of the address in Bitpay format\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype._toStringBitpay = function () {\n  var buffer = this.toBuffer();\n\n  if (this.network.toString() === 'livenet') {\n    if (this.type === Address.PayToPublicKeyHash) {\n      buffer[0] = BITPAY_P2PKH_VERSION_BYTE;\n    } else if (this.type === Address.PayToScriptHash) {\n      buffer[0] = BITPAY_P2SH_VERSION_BYTE;\n    }\n  }\n\n  return Base58Check.encode(buffer);\n};\n/**\n * Will return a the string representation of the address in CashAddr format\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype._toStringCashAddr = function () {\n  var prefix = this.network.toString() === 'livenet' ? 'bitcoincash' : 'bchtest';\n  var type = this.type === Address.PayToPublicKeyHash ? 'P2PKH' : 'P2SH';\n  return cashaddr.encode(prefix, type, this.hashBuffer);\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\n\n\nAddress.prototype.inspect = function () {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');","map":{"version":3,"sources":["/Users/anthonypafundi/Desktop/baseapp/node_modules/bitcoincashjs/src/address.js"],"names":["_","require","$","cashaddr","errors","Base58Check","Networks","Hash","JSUtil","PublicKey","BITPAY_P2PKH_VERSION_BYTE","BITPAY_P2SH_VERSION_BYTE","Address","data","network","type","isArray","isNumber","createMultisig","checkArgument","get","TypeError","PayToPublicKeyHash","PayToScriptHash","info","_classifyArguments","defaultNetwork","defineImmutable","hashBuffer","prototype","Buffer","Uint8Array","length","_transformHash","_transformBuffer","_transformPublicKey","Script","_transformScript","_transformString","DefaultFormat","isObject","_transformObject","LegacyFormat","BitpayFormat","CashAddrFormat","hash","_classifyFromVersion","buffer","version","pubkeyhashNetwork","scripthashNetwork","bufferVersion","slice","pubkey","sha256ripemd160","toBuffer","script","getAddressInfo","CantDeriveAddress","publicKeys","threshold","payingTo","buildMultisigOut","format","trim","_transformStringLegacy","_transformStringBitpay","_transformStringCashAddr","addressBuffer","decode","toString","decoded","prefix","concat","fromPublicKey","fromPublicKeyHash","fromScriptHash","fromScript","fromBuffer","fromString","str","fromObject","obj","checkState","isHexa","getValidationError","error","e","isValid","isPayToPublicKeyHash","isPayToScriptHash","buf","toObject","toJSON","_toStringLegacy","_toStringBitpay","_toStringCashAddr","encode","inspect","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar cashaddr = require('cashaddrjs');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\n\nvar BITPAY_P2PKH_VERSION_BYTE = 28;\nvar BITPAY_P2SH_VERSION_BYTE = 40;\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\n * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash` and `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n    return Address._transformHash(data);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type, Address.DefaultFormat);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.LegacyFormat = 'legacy';\n/** @static */\nAddress.BitpayFormat = 'bitpay';\n/** @static */\nAddress.CashAddrFormat = 'cashaddr';\n/** @static */\nAddress.DefaultFormat = Address.LegacyFormat;\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20) {\n    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n  }\n  info.hashBuffer = hash;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? new Buffer(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n  if (pubkeyhashNetwork) {\n    version.network = pubkeyhashNetwork;\n    version.type = Address.PayToPublicKeyHash;\n  } else if (scripthashNetwork) {\n    version.network = scripthashNetwork;\n    version.type = Address.PayToScriptHash;\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (buffer.length !== 1 + 20) {\n    throw new TypeError('Address buffers must be exactly 21 bytes.');\n  }\n\n  network = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (!bufferVersion.network || (network && network !== bufferVersion.network)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  info.hashBuffer = buffer.slice(1);\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  info.type = Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @param {string} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type, format) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n  data = data.trim();\n  if (format === Address.LegacyFormat) {\n    return Address._transformStringLegacy(data, network, type);\n  }\n  else if (format === Address.BitpayFormat) {\n    return Address._transformStringBitpay(data, network, type);\n  }\n  else if (format === Address.CashAddrFormat) {\n    return Address._transformStringCashAddr(data, network, type);\n  }\n  throw new TypeError('Unrecognized address format.');\n};\n\n/**\n * Internal function to transform a bitcoin address string in legacy format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringLegacy = function(data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string in Bitpay format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringBitpay = function(data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  if (addressBuffer[0] === BITPAY_P2PKH_VERSION_BYTE) {\n    addressBuffer[0] = 0;\n  }\n  else if (addressBuffer[0] === BITPAY_P2SH_VERSION_BYTE) {\n    addressBuffer[0] = 5;\n  }\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string in CashAddr format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringCashAddr = function(data, network, type) {\n  if (!(typeof network === 'string')) {\n    network = network.toString();\n  }\n  var decoded = cashaddr.decode(data);\n  $.checkArgument(\n      !network ||\n          (network === 'livenet' && decoded.prefix === 'bitcoincash') ||\n          (network === 'testnet' && decoded.prefix === 'bchtest'),\n      'Invalid network.'\n  );\n  $.checkArgument(\n    !type ||\n        (type === Address.PayToPublicKeyHash && decoded.type === 'P2PKH') ||\n        (type === Address.PayToScriptHash && decoded.type === 'P2SH'),\n    'Invalid type.'\n  );\n  network = Networks.get(network ||\n      (decoded.prefix === 'bitcoincash' ? 'livenet' : 'testnet')\n  );\n  type = type ||\n      (decoded.type === 'P2PKH' ? Address.PayToPublicKeyHash : Address.PayToScriptHash);\n  var version = new Buffer([network[type]]);\n  var hashBuffer = new Buffer(decoded.hash);\n  var addressBuffer = Buffer.concat([version, hashBuffer]);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network) {\n  var info = Address._transformPublicKey(data);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToScriptHash);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n\n  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type, format) {\n  format = format || Address.DefaultFormat;\n  var info = Address._transformString(str, network, type, format);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = new Buffer(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  var version = new Buffer([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function(format) {\n  format = format || Address.DefaultFormat;\n  if (format === Address.LegacyFormat) {\n    return this._toStringLegacy();\n  }\n  else if (format === Address.BitpayFormat) {\n    return this._toStringBitpay();\n  }\n  else if (format === Address.CashAddrFormat) {\n    return this._toStringCashAddr();\n  }\n  throw new TypeError('Unrecognized address format.');\n};\n\n/**\n * Will return a the string representation of the address in legacy format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringLegacy = function() {\n  return Base58Check.encode(this.toBuffer());\n}\n\n/**\n * Will return a the string representation of the address in Bitpay format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringBitpay = function() {\n  var buffer = this.toBuffer();\n  if (this.network.toString() === 'livenet') {\n    if (this.type === Address.PayToPublicKeyHash) {\n      buffer[0] = BITPAY_P2PKH_VERSION_BYTE;\n    }\n    else if (this.type === Address.PayToScriptHash) {\n      buffer[0] = BITPAY_P2SH_VERSION_BYTE;\n    }\n  }\n  return Base58Check.encode(buffer);\n}\n\n/**\n * Will return a the string representation of the address in CashAddr format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringCashAddr = function() {\n  var prefix = this.network.toString() === 'livenet' ? 'bitcoincash' : 'bchtest';\n  var type = this.type === Address.PayToPublicKeyHash ? 'P2PKH' : 'P2SH';\n  return cashaddr.encode(prefix, type, this.hashBuffer);\n}\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');\n"]},"metadata":{},"sourceType":"script"}