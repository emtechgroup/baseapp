{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Transaction = require('../transaction');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar Sighash = require('../sighash');\n\nvar PublicKey = require('../../publickey');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar TransactionSignature = require('../signature');\n/**\n * @constructor\n */\n\n\nfunction MultiSigInput(input, pubkeys, threshold, signatures) {\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n    return publicKey.toString('hex');\n  });\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script), 'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n\n  this.threshold = threshold; // Empty array of signatures\n\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\n\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n  var self = this;\n  var results = [];\n\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, self.output.satoshisBN),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function (transaction, signature) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n  this._updateScript();\n\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function () {\n  this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures()));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function () {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\n\nMultiSigInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function (transaction, signature) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN);\n};\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\n\n\nMultiSigInput.normalizeSignatures = function (transaction, input, inputIndex, signatures, publicKeys) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script);\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function () {\n  return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;","map":{"version":3,"sources":["/Users/anthonypafundi/Desktop/baseapp/node_modules/bitcoincashjs/src/transaction/input/multisig.js"],"names":["_","require","inherits","Transaction","Input","Output","$","Script","Signature","Sighash","PublicKey","BufferUtil","TransactionSignature","MultiSigInput","input","pubkeys","threshold","signatures","apply","arguments","self","publicKeys","sortBy","publicKey","toString","checkState","buildMultisigOut","equals","output","script","publicKeyIndex","each","index","_deserializeSignatures","Array","length","prototype","toObject","obj","map","_serializeSignatures","signature","undefined","getSignatures","transaction","privateKey","sigtype","SIGHASH_ALL","SIGHASH_FORKID","results","push","prevTxId","outputIndex","inputIndex","sign","satoshisBN","addSignature","isFullySigned","checkArgument","isUndefined","isValidSignature","_updateScript","setScript","buildMultisigIn","_createSignatures","filter","concat","toDER","integerAsSingleByteBuffer","clearSignatures","countSignatures","countMissingSignatures","reduce","sum","publicKeysWithoutSignature","nhashtype","verify","normalizeSignatures","pubKey","signatureMatch","signatureBuffer","fromTxFormat","isMatch","OPCODES_SIZE","SIGNATURE_SIZE","_estimateSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Transaction = require('../transaction');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar PublicKey = require('../../publickey');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures) {\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || (Signature.SIGHASH_ALL |  Signature.SIGHASH_FORKID);\n\n  var self = this;\n  var results = [];\n  _.each(this.publicKeys, function(publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script, self.output.satoshisBN),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function() {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures()\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script,\n    this.output.satoshisBN\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n"]},"metadata":{},"sourceType":"script"}