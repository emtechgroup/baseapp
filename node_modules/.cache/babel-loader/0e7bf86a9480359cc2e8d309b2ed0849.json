{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar Address = require('./address');\n\nvar PublicKey = require('./publickey');\n\nvar PrivateKey = require('./privatekey');\n\nvar BufferWriter = require('./encoding/bufferwriter');\n\nvar ECDSA = require('./crypto/ecdsa');\n\nvar Signature = require('./crypto/signature');\n\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\n\nvar JSUtil = require('./util/js');\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @returns {Message}\n */\n\n\nvar Message = function Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n  return this;\n};\n\nMessage.MAGIC_BYTES = new Buffer('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = new Buffer(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  console.log(privateKey);\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\n\n\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n\n  return verified;\n};\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\n\n\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n\n  var signature = Signature.fromCompact(new Buffer(signatureString, 'base64')); // recover the public key\n\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network); // check that the recovered address and specified address match\n\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\n\n\nMessage.fromString = function (str) {\n  return new Message(str);\n};\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\n\n\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n\n  return new Message(json.message);\n};\n/**\n * @returns {Object} A plain object with the message information\n */\n\n\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n/**\n * @returns {String} A JSON representation of the message information\n */\n\n\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\n\n\nMessage.prototype.toString = function () {\n  return this.message;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\n\n\nMessage.prototype.inspect = function () {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;","map":{"version":3,"sources":["/Users/anthonypafundi/Desktop/baseapp/node_modules/bitcoincashjs/src/message.js"],"names":["_","require","$","Address","PublicKey","PrivateKey","BufferWriter","ECDSA","Signature","sha256sha256","JSUtil","Message","message","checkArgument","isString","MAGIC_BYTES","Buffer","prototype","magicHash","prefix1","varintBufNum","length","messageBuffer","prefix2","buf","concat","hash","_sign","privateKey","console","log","ecdsa","hashbuf","privkey","pubkey","toPublicKey","signRandomK","calci","sig","sign","signature","toCompact","toString","_verify","publicKey","verified","verify","error","bitcoinAddress","signatureString","fromString","fromCompact","signatureAddress","fromPublicKey","network","str","fromJSON","json","isValidJSON","JSON","parse","toObject","toJSON","stringify","inspect","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar Address = require('./address');\nvar PublicKey = require('./publickey');\nvar PrivateKey = require('./privatekey');\nvar BufferWriter = require('./encoding/bufferwriter');\nvar ECDSA = require('./crypto/ecdsa');\nvar Signature = require('./crypto/signature');\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\nvar JSUtil = require('./util/js');\n\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @returns {Message}\n */\nvar Message = function Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n\n  return this;\n};\n\nMessage.MAGIC_BYTES = new Buffer('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = new Buffer(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  console.log(privateKey);\n  $.checkArgument(privateKey instanceof PrivateKey,\n    'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(new Buffer(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function(str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function() {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function() {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n"]},"metadata":{},"sourceType":"script"}