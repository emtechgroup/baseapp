{"ast":null,"code":"import _slicedToArray from \"/Users/anthonypafundi/Desktop/baseapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/anthonypafundi/Desktop/baseapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(writter),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(reader),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(watchDisconnect),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(bindSocket),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(dispatchCurrentMarketOrderUpdates),\n    _marked6 = /*#__PURE__*/_regeneratorRuntime.mark(dispatchOrderHistoryUpdates),\n    _marked7 = /*#__PURE__*/_regeneratorRuntime.mark(getSubscriptions),\n    _marked8 = /*#__PURE__*/_regeneratorRuntime.mark(rangerSagas);\n\nimport { eventChannel } from 'redux-saga';\nimport { all, call, cancel, delay, fork, put, race, select, take, takeEvery } from 'redux-saga/effects';\nimport { isFinexEnabled, rangerUrl } from '../../../../api';\nimport { store } from '../../../../store';\nimport { pushHistoryEmit } from '../../../user/history';\nimport { selectOpenOrdersList, userOpenOrdersUpdate } from '../../../user/openOrders';\nimport { userOrdersHistoryRangerData } from '../../../user/ordersHistory';\nimport { updateWalletsDataByRanger, walletsAddressDataWS } from '../../../user/wallets';\nimport { alertPush } from '../../alert';\nimport { klinePush } from '../../kline';\nimport { marketsTickersData, selectCurrentMarket } from '../../markets';\nimport { MARKETS_SET_CURRENT_MARKET, MARKETS_SET_CURRENT_MARKET_IFUNSET } from '../../markets/constants';\nimport { depthData, depthDataIncrement, depthDataSnapshot, selectOrderBookSequence } from '../../orderBook';\nimport { recentTradesPush } from '../../recentTrades';\nimport { rangerDisconnectData, rangerDisconnectFetch, rangerSubscribeMarket, rangerUnsubscribeMarket, rangerUserOrderUpdate, subscriptionsUpdate } from '../actions';\nimport { RANGER_CONNECT_DATA, RANGER_CONNECT_FETCH, RANGER_DIRECT_WRITE, RANGER_DISCONNECT_DATA, RANGER_DISCONNECT_FETCH, RANGER_USER_ORDER_UPDATE } from '../constants';\nimport { formatTicker, generateSocketURI, streamsBuilder } from '../helpers';\nimport { selectSubscriptions } from '../selectors';\n\nvar initRanger = function initRanger(_ref, market, prevSubs, buffer) {\n  var withAuth = _ref.withAuth;\n  var baseUrl = \"\".concat(rangerUrl(), \"/\").concat(withAuth ? 'private' : 'public');\n  var streams = streamsBuilder(withAuth, prevSubs, market);\n  var ws = new WebSocket(generateSocketURI(baseUrl, streams));\n  var channel = eventChannel(function (emitter) {\n    ws.onopen = function () {\n      emitter({\n        type: RANGER_CONNECT_DATA\n      });\n\n      while (buffer.messages.length > 0) {\n        var message = buffer.messages.shift();\n        ws.send(JSON.stringify(message));\n      }\n    };\n\n    ws.onerror = function (error) {\n      window.console.log(\"WebSocket error \".concat(error));\n      window.console.dir(error);\n    };\n\n    ws.onclose = function (event) {\n      channel.close();\n    };\n\n    ws.onmessage = function (_ref2) {\n      var data = _ref2.data;\n      var payload = {};\n\n      try {\n        payload = JSON.parse(data);\n      } catch (e) {\n        window.console.error(\"Error parsing : \".concat(e.data));\n      }\n\n      for (var routingKey in payload) {\n        if (payload.hasOwnProperty(routingKey)) {\n          var _ret = function () {\n            var event = payload[routingKey];\n            var currentMarket = selectCurrentMarket(store.getState());\n            var orderBookMatch = routingKey.match(/([^.]*)\\.update/);\n            var orderBookMatchSnap = routingKey.match(/([^.]*)\\.ob-snap/);\n            var orderBookMatchInc = routingKey.match(/([^.]*)\\.ob-inc/); // public\n\n            if (orderBookMatch) {\n              if (currentMarket && orderBookMatch[1] === currentMarket.id) {\n                emitter(depthData(event));\n              }\n\n              return {\n                v: void 0\n              };\n            } // public\n\n\n            if (orderBookMatchSnap) {\n              if (currentMarket && orderBookMatchSnap[1] === currentMarket.id) {\n                emitter(depthDataSnapshot(event));\n              }\n\n              return {\n                v: void 0\n              };\n            } // public\n\n\n            if (orderBookMatchInc) {\n              if (currentMarket && orderBookMatchInc[1] === currentMarket.id) {\n                var previousSequence = selectOrderBookSequence(store.getState());\n\n                if (previousSequence === null) {\n                  window.console.log('OrderBook increment received before snapshot');\n                  return {\n                    v: void 0\n                  };\n                }\n\n                if (previousSequence + 1 !== event.sequence) {\n                  window.console.log(\"Bad sequence detected in incremental orderbook previous: \".concat(previousSequence, \", event: \").concat(event.sequence));\n                  emitter(rangerDisconnectFetch());\n                  return {\n                    v: void 0\n                  };\n                }\n\n                emitter(depthDataIncrement(event));\n              }\n\n              return {\n                v: void 0\n              };\n            } // public\n\n\n            var klineMatch = String(routingKey).match(/([^.]*)\\.kline-(.+)/);\n\n            if (klineMatch) {\n              emitter(klinePush({\n                marketId: klineMatch[1],\n                kline: event,\n                period: klineMatch[2]\n              }));\n              return {\n                v: void 0\n              };\n            } // public\n\n\n            var tradesMatch = String(routingKey).match(/([^.]*)\\.trades/);\n\n            if (tradesMatch) {\n              emitter(recentTradesPush({\n                trades: event.trades,\n                market: tradesMatch[1]\n              }));\n              return {\n                v: void 0\n              };\n            }\n\n            switch (routingKey) {\n              // public\n              case 'global.tickers':\n                emitter(marketsTickersData(formatTicker(event)));\n                return {\n                  v: void 0\n                };\n              // public\n\n              case 'success':\n                switch (event.message) {\n                  case 'subscribed':\n                  case 'unsubscribed':\n                    emitter(subscriptionsUpdate({\n                      subscriptions: event.streams\n                    }));\n                    return {\n                      v: void 0\n                    };\n\n                  default:\n                }\n\n                return {\n                  v: void 0\n                };\n              // private\n\n              case 'order':\n                if (isFinexEnabled() && event) {\n                  switch (event.state) {\n                    case 'wait':\n                    case 'pending':\n                      var orders = selectOpenOrdersList(store.getState());\n                      var updatedOrder = orders.length && orders.find(function (order) {\n                        return event.uuid && order.uuid === event.uuid;\n                      });\n\n                      if (!updatedOrder) {\n                        emitter(alertPush({\n                          message: ['success.order.created'],\n                          type: 'success'\n                        }));\n                      }\n\n                      break;\n\n                    case 'done':\n                      emitter(alertPush({\n                        message: ['success.order.done'],\n                        type: 'success'\n                      }));\n                      break;\n\n                    case 'reject':\n                      emitter(alertPush({\n                        message: ['error.order.rejected'],\n                        type: 'error'\n                      }));\n                      break;\n\n                    default:\n                      break;\n                  }\n                }\n\n                emitter(rangerUserOrderUpdate(event));\n                return {\n                  v: void 0\n                };\n              // private\n\n              case 'trade':\n                emitter(pushHistoryEmit(event));\n                return {\n                  v: void 0\n                };\n              // private\n\n              case 'balances':\n                emitter(updateWalletsDataByRanger({\n                  ws: true,\n                  balances: event\n                }));\n                return {\n                  v: void 0\n                };\n              // private\n\n              case 'deposit_address':\n                emitter(walletsAddressDataWS(event));\n                return {\n                  v: void 0\n                };\n\n              default:\n            }\n\n            window.console.log(\"Unhandeled websocket channel: \".concat(routingKey));\n          }();\n\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n      }\n    }; // unsubscribe function\n\n\n    return function () {\n      emitter(rangerDisconnectData());\n    };\n  });\n  return [channel, ws];\n};\n\nfunction writter(socket, buffer) {\n  var data;\n  return _regeneratorRuntime.wrap(function writter$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!true) {\n            _context.next = 7;\n            break;\n          }\n\n          _context.next = 3;\n          return take(RANGER_DIRECT_WRITE);\n\n        case 3:\n          data = _context.sent;\n\n          if (socket.readyState === socket.OPEN) {\n            socket.send(JSON.stringify(data.payload));\n          } else {\n            buffer.messages.push(data.payload);\n          }\n\n          _context.next = 0;\n          break;\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction reader(channel) {\n  var action;\n  return _regeneratorRuntime.wrap(function reader$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!true) {\n            _context2.next = 8;\n            break;\n          }\n\n          _context2.next = 3;\n          return take(channel);\n\n        case 3:\n          action = _context2.sent;\n          _context2.next = 6;\n          return put(action);\n\n        case 6:\n          _context2.next = 0;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nvar previousMarket;\n\nvar switchMarket = function switchMarket(subscribeOnInitOnly) {\n  return /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action) {\n    return _regeneratorRuntime.wrap(function _callee$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(subscribeOnInitOnly && previousMarket !== undefined)) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 2:\n            if (!(previousMarket && previousMarket.id !== action.payload.id)) {\n              _context3.next = 5;\n              break;\n            }\n\n            _context3.next = 5;\n            return put(rangerUnsubscribeMarket(previousMarket));\n\n          case 5:\n            previousMarket = action.payload;\n\n            if (!action.payload) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.next = 9;\n            return put(rangerSubscribeMarket(action.payload));\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee);\n  });\n};\n\nfunction watchDisconnect(socket, channel) {\n  return _regeneratorRuntime.wrap(function watchDisconnect$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return take(RANGER_DISCONNECT_FETCH);\n\n        case 2:\n          socket.close();\n\n        case 3:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction bindSocket(channel, socket, buffer) {\n  return _regeneratorRuntime.wrap(function bindSocket$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return all([call(reader, channel), call(writter, socket, buffer), call(watchDisconnect, socket, channel)]);\n\n        case 2:\n          return _context5.abrupt(\"return\", _context5.sent);\n\n        case 3:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked4);\n}\n\nfunction dispatchCurrentMarketOrderUpdates(action) {\n  var market;\n  return _regeneratorRuntime.wrap(function dispatchCurrentMarketOrderUpdates$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          _context6.prev = 0;\n          _context6.next = 3;\n          return select(selectCurrentMarket);\n\n        case 3:\n          market = _context6.sent;\n          _context6.next = 9;\n          break;\n\n        case 6:\n          _context6.prev = 6;\n          _context6.t0 = _context6[\"catch\"](0);\n          market = undefined;\n\n        case 9:\n          if (!(market && action.payload.market === market.id)) {\n            _context6.next = 12;\n            break;\n          }\n\n          _context6.next = 12;\n          return put(userOpenOrdersUpdate(action.payload));\n\n        case 12:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked5, null, [[0, 6]]);\n}\n\nfunction dispatchOrderHistoryUpdates(action) {\n  return _regeneratorRuntime.wrap(function dispatchOrderHistoryUpdates$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          _context7.next = 2;\n          return put(userOrdersHistoryRangerData(action.payload));\n\n        case 2:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, _marked6);\n}\n\nfunction getSubscriptions() {\n  return _regeneratorRuntime.wrap(function getSubscriptions$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.prev = 0;\n          _context8.next = 3;\n          return select(selectSubscriptions);\n\n        case 3:\n          return _context8.abrupt(\"return\", _context8.sent);\n\n        case 6:\n          _context8.prev = 6;\n          _context8.t0 = _context8[\"catch\"](0);\n          return _context8.abrupt(\"return\", []);\n\n        case 9:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, _marked7, null, [[0, 6]]);\n}\n\nexport function rangerSagas() {\n  var initialized, connectFetchPayload, buffer, pipes, _yield$race, connectFetch, disconnectData, market, prevSubs, _yield$call, _yield$call2, channel, socket;\n\n  return _regeneratorRuntime.wrap(function rangerSagas$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          initialized = false;\n          buffer = {\n            messages: []\n          };\n          _context9.next = 4;\n          return takeEvery(MARKETS_SET_CURRENT_MARKET, switchMarket(false));\n\n        case 4:\n          _context9.next = 6;\n          return takeEvery(MARKETS_SET_CURRENT_MARKET_IFUNSET, switchMarket(true));\n\n        case 6:\n          _context9.next = 8;\n          return takeEvery(RANGER_USER_ORDER_UPDATE, dispatchCurrentMarketOrderUpdates);\n\n        case 8:\n          _context9.next = 10;\n          return takeEvery(RANGER_USER_ORDER_UPDATE, dispatchOrderHistoryUpdates);\n\n        case 10:\n          if (!true) {\n            _context9.next = 55;\n            break;\n          }\n\n          _context9.next = 13;\n          return race({\n            connectFetch: take(RANGER_CONNECT_FETCH),\n            disconnectData: take(RANGER_DISCONNECT_DATA)\n          });\n\n        case 13:\n          _yield$race = _context9.sent;\n          connectFetch = _yield$race.connectFetch;\n          disconnectData = _yield$race.disconnectData;\n          market = void 0;\n\n          if (!connectFetch) {\n            _context9.next = 24;\n            break;\n          }\n\n          if (!initialized) {\n            _context9.next = 23;\n            break;\n          }\n\n          _context9.next = 21;\n          return put(rangerDisconnectFetch());\n\n        case 21:\n          _context9.next = 23;\n          return take(RANGER_DISCONNECT_DATA);\n\n        case 23:\n          connectFetchPayload = connectFetch.payload;\n\n        case 24:\n          if (!disconnectData) {\n            _context9.next = 27;\n            break;\n          }\n\n          _context9.next = 27;\n          return delay(1000);\n\n        case 27:\n          _context9.prev = 27;\n          _context9.next = 30;\n          return select(selectCurrentMarket);\n\n        case 30:\n          market = _context9.sent;\n          _context9.next = 36;\n          break;\n\n        case 33:\n          _context9.prev = 33;\n          _context9.t0 = _context9[\"catch\"](27);\n          market = undefined;\n\n        case 36:\n          if (!connectFetchPayload) {\n            _context9.next = 53;\n            break;\n          }\n\n          _context9.next = 39;\n          return getSubscriptions();\n\n        case 39:\n          prevSubs = _context9.sent;\n          _context9.next = 42;\n          return call(initRanger, connectFetchPayload, market, prevSubs, buffer);\n\n        case 42:\n          _yield$call = _context9.sent;\n          _yield$call2 = _slicedToArray(_yield$call, 2);\n          channel = _yield$call2[0];\n          socket = _yield$call2[1];\n          initialized = true;\n\n          if (!pipes) {\n            _context9.next = 50;\n            break;\n          }\n\n          _context9.next = 50;\n          return cancel(pipes);\n\n        case 50:\n          _context9.next = 52;\n          return fork(bindSocket, channel, socket, buffer);\n\n        case 52:\n          pipes = _context9.sent;\n\n        case 53:\n          _context9.next = 10;\n          break;\n\n        case 55:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, _marked8, null, [[27, 33]]);\n}","map":{"version":3,"sources":["/Users/anthonypafundi/Desktop/baseapp/src/modules/public/ranger/sagas/rangerSaga.ts"],"names":["writter","reader","watchDisconnect","bindSocket","dispatchCurrentMarketOrderUpdates","dispatchOrderHistoryUpdates","getSubscriptions","rangerSagas","eventChannel","all","call","cancel","delay","fork","put","race","select","take","takeEvery","isFinexEnabled","rangerUrl","store","pushHistoryEmit","selectOpenOrdersList","userOpenOrdersUpdate","userOrdersHistoryRangerData","updateWalletsDataByRanger","walletsAddressDataWS","alertPush","klinePush","marketsTickersData","selectCurrentMarket","MARKETS_SET_CURRENT_MARKET","MARKETS_SET_CURRENT_MARKET_IFUNSET","depthData","depthDataIncrement","depthDataSnapshot","selectOrderBookSequence","recentTradesPush","rangerDisconnectData","rangerDisconnectFetch","rangerSubscribeMarket","rangerUnsubscribeMarket","rangerUserOrderUpdate","subscriptionsUpdate","RANGER_CONNECT_DATA","RANGER_CONNECT_FETCH","RANGER_DIRECT_WRITE","RANGER_DISCONNECT_DATA","RANGER_DISCONNECT_FETCH","RANGER_USER_ORDER_UPDATE","formatTicker","generateSocketURI","streamsBuilder","selectSubscriptions","initRanger","market","prevSubs","buffer","withAuth","baseUrl","streams","ws","WebSocket","channel","emitter","onopen","type","messages","length","message","shift","send","JSON","stringify","onerror","error","window","console","log","dir","onclose","event","close","onmessage","data","payload","parse","e","routingKey","hasOwnProperty","currentMarket","getState","orderBookMatch","match","orderBookMatchSnap","orderBookMatchInc","id","previousSequence","sequence","klineMatch","String","marketId","kline","period","tradesMatch","trades","subscriptions","state","orders","updatedOrder","find","order","uuid","balances","socket","readyState","OPEN","push","action","previousMarket","switchMarket","subscribeOnInitOnly","undefined","initialized","connectFetch","disconnectData","connectFetchPayload","pipes"],"mappings":"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","sourcesContent":["import { Channel, eventChannel, EventChannel } from 'redux-saga';\nimport { all, call, cancel, delay, fork, put, race, select, take, takeEvery } from 'redux-saga/effects';\nimport { isFinexEnabled, rangerUrl } from '../../../../api';\nimport { store } from '../../../../store';\nimport { pushHistoryEmit } from '../../../user/history';\nimport { selectOpenOrdersList, userOpenOrdersUpdate } from '../../../user/openOrders';\nimport { userOrdersHistoryRangerData} from '../../../user/ordersHistory';\nimport { updateWalletsDataByRanger, walletsAddressDataWS } from '../../../user/wallets';\nimport { alertPush } from '../../alert';\nimport { klinePush } from '../../kline';\nimport { Market, marketsTickersData, selectCurrentMarket, SetCurrentMarket } from '../../markets';\nimport { MARKETS_SET_CURRENT_MARKET, MARKETS_SET_CURRENT_MARKET_IFUNSET } from '../../markets/constants';\nimport { depthData, depthDataIncrement, depthDataSnapshot, selectOrderBookSequence } from '../../orderBook';\nimport { recentTradesPush } from '../../recentTrades';\nimport {\n    RangerConnectFetch,\n    rangerDisconnectData,\n    rangerDisconnectFetch,\n    rangerSubscribeMarket,\n    rangerUnsubscribeMarket,\n    rangerUserOrderUpdate,\n    subscriptionsUpdate,\n    UserOrderUpdate,\n} from '../actions';\nimport {\n    RANGER_CONNECT_DATA,\n    RANGER_CONNECT_FETCH,\n    RANGER_DIRECT_WRITE,\n    RANGER_DISCONNECT_DATA,\n    RANGER_DISCONNECT_FETCH,\n    RANGER_USER_ORDER_UPDATE,\n} from '../constants';\nimport { formatTicker, generateSocketURI, streamsBuilder } from '../helpers';\nimport { selectSubscriptions } from '../selectors';\n\ninterface RangerBuffer {\n    messages: object[];\n}\n\nconst initRanger = (\n    { withAuth }: RangerConnectFetch['payload'],\n    market: Market | undefined,\n    prevSubs: string[],\n    buffer: RangerBuffer,\n): [EventChannel<any>, WebSocket] => {\n    const baseUrl = `${rangerUrl()}/${withAuth ? 'private' : 'public'}`;\n    const streams = streamsBuilder(withAuth, prevSubs, market);\n\n    const ws = new WebSocket(generateSocketURI(baseUrl, streams));\n    const channel = eventChannel(emitter => {\n        ws.onopen = () => {\n            emitter({ type: RANGER_CONNECT_DATA });\n            while (buffer.messages.length > 0) {\n                const message = buffer.messages.shift();\n                ws.send(JSON.stringify(message));\n            }\n        };\n        ws.onerror = error => {\n            window.console.log(`WebSocket error ${error}`);\n            window.console.dir(error);\n        };\n        ws.onclose = event => {\n            channel.close();\n        };\n        ws.onmessage = ({ data }) => {\n            let payload: { [pair: string]: any } = {};\n\n            try {\n                payload = JSON.parse(data as string);\n            } catch (e) {\n                window.console.error(`Error parsing : ${e.data}`);\n            }\n\n            for (const routingKey in payload) {\n                if (payload.hasOwnProperty(routingKey)) {\n                    const event = payload[routingKey];\n\n                    const currentMarket = selectCurrentMarket(store.getState());\n                    const orderBookMatch = routingKey.match(/([^.]*)\\.update/);\n                    const orderBookMatchSnap = routingKey.match(/([^.]*)\\.ob-snap/);\n                    const orderBookMatchInc = routingKey.match(/([^.]*)\\.ob-inc/);\n\n                    // public\n                    if (orderBookMatch) {\n                        if (currentMarket && orderBookMatch[1] === currentMarket.id) {\n                            emitter(depthData(event));\n                        }\n\n                        return;\n                    }\n\n                    // public\n                    if (orderBookMatchSnap) {\n                        if (currentMarket && orderBookMatchSnap[1] === currentMarket.id) {\n                            emitter(depthDataSnapshot(event));\n                        }\n\n                        return;\n                    }\n\n                    // public\n                    if (orderBookMatchInc) {\n                        if (currentMarket && orderBookMatchInc[1] === currentMarket.id) {\n                            const previousSequence = selectOrderBookSequence(store.getState());\n                            if (previousSequence === null) {\n                                window.console.log('OrderBook increment received before snapshot');\n\n                                return;\n                            }\n                            if (previousSequence + 1 !== event.sequence) {\n                                window.console.log(`Bad sequence detected in incremental orderbook previous: ${previousSequence}, event: ${event.sequence}`);\n                                emitter(rangerDisconnectFetch());\n\n                                return;\n                            }\n                            emitter(depthDataIncrement(event));\n                        }\n\n                        return;\n                    }\n\n                    // public\n                    const klineMatch = String(routingKey).match(/([^.]*)\\.kline-(.+)/);\n                    if (klineMatch) {\n                        emitter(\n                            klinePush({\n                                marketId: klineMatch[1],\n                                kline: event,\n                                period: klineMatch[2],\n                            }),\n                        );\n\n                        return;\n                    }\n\n                    // public\n                    const tradesMatch = String(routingKey).match(/([^.]*)\\.trades/);\n                    if (tradesMatch) {\n                        emitter(\n                            recentTradesPush({\n                                trades: event.trades,\n                                market: tradesMatch[1],\n                            }),\n                        );\n\n                        return;\n                    }\n\n                    switch (routingKey) {\n                        // public\n                        case 'global.tickers':\n                            emitter(marketsTickersData(formatTicker(event)));\n\n                            return;\n\n                        // public\n                        case 'success':\n                            switch (event.message) {\n                                case 'subscribed':\n                                case 'unsubscribed':\n                                    emitter(subscriptionsUpdate({ subscriptions: event.streams }));\n\n                                    return;\n                                default:\n                            }\n\n                            return;\n\n                        // private\n                        case 'order':\n                            if (isFinexEnabled() && event) {\n                                switch (event.state) {\n                                    case 'wait':\n                                    case 'pending':\n                                        const orders = selectOpenOrdersList(store.getState());\n                                        const updatedOrder = orders.length && orders.find(order => event.uuid && order.uuid === event.uuid);\n                                        if (!updatedOrder) {\n                                            emitter(alertPush({ message: ['success.order.created'], type: 'success'}));\n                                        }\n                                        break;\n                                    case 'done':\n                                        emitter(alertPush({ message: ['success.order.done'], type: 'success'}));\n                                        break;\n                                    case 'reject':\n                                        emitter(alertPush({ message: ['error.order.rejected'], type: 'error'}));\n                                        break;\n                                    default:\n                                        break;\n                                }\n                            }\n\n                            emitter(rangerUserOrderUpdate(event));\n\n                            return;\n\n                        // private\n                        case 'trade':\n                            emitter(pushHistoryEmit(event));\n\n                            return;\n\n                        // private\n                        case 'balances':\n                            emitter(updateWalletsDataByRanger({ ws: true, balances: event }));\n\n                            return;\n\n                        // private\n                        case 'deposit_address':\n                            emitter(walletsAddressDataWS(event));\n\n                            return;\n\n                        default:\n                    }\n                    window.console.log(`Unhandeled websocket channel: ${routingKey}`);\n                }\n            }\n        };\n\n        // unsubscribe function\n        return () => {\n            emitter(rangerDisconnectData());\n        };\n    });\n\n    return [channel, ws];\n};\n\nfunction* writter(socket: WebSocket, buffer: { messages: object[] }) {\n    while (true) {\n        const data = yield take(RANGER_DIRECT_WRITE);\n        if (socket.readyState === socket.OPEN) {\n            socket.send(JSON.stringify(data.payload));\n        } else {\n            buffer.messages.push(data.payload);\n        }\n    }\n}\n\nfunction* reader(channel) {\n    while (true) {\n        const action = yield take(channel);\n        yield put(action);\n    }\n}\n\nlet previousMarket: Market | undefined;\n\nconst switchMarket = (subscribeOnInitOnly: boolean) => {\n    return function*(action: SetCurrentMarket) {\n        if (subscribeOnInitOnly && previousMarket !== undefined) {\n            return;\n        }\n        if (previousMarket && previousMarket.id !== action.payload.id) {\n            yield put(rangerUnsubscribeMarket(previousMarket));\n        }\n        previousMarket = action.payload;\n        if (action.payload) {\n            yield put(rangerSubscribeMarket(action.payload));\n        }\n    };\n};\n\nfunction* watchDisconnect(socket: WebSocket, channel: Channel<{}>) {\n    yield take(RANGER_DISCONNECT_FETCH);\n    socket.close();\n}\n\nfunction* bindSocket(channel: Channel<{}>, socket: WebSocket, buffer: RangerBuffer) {\n    return yield all([call(reader, channel), call(writter, socket, buffer), call(watchDisconnect, socket, channel)]);\n}\n\nfunction* dispatchCurrentMarketOrderUpdates(action: UserOrderUpdate) {\n    let market;\n\n    try {\n        market = yield select(selectCurrentMarket);\n    } catch (error) {\n        market = undefined;\n    }\n\n    if (market && action.payload.market === market.id) {\n        yield put(userOpenOrdersUpdate(action.payload));\n    }\n}\n\nfunction* dispatchOrderHistoryUpdates(action: UserOrderUpdate) {\n    yield put(userOrdersHistoryRangerData(action.payload));\n}\n\nfunction* getSubscriptions() {\n    try {\n        return yield select(selectSubscriptions);\n    } catch (error) {\n        return [];\n    }\n}\n\nexport function* rangerSagas() {\n    let initialized = false;\n    let connectFetchPayload: RangerConnectFetch['payload'] | undefined;\n    const buffer: RangerBuffer = { messages: [] };\n    let pipes;\n    yield takeEvery(MARKETS_SET_CURRENT_MARKET, switchMarket(false));\n    yield takeEvery(MARKETS_SET_CURRENT_MARKET_IFUNSET, switchMarket(true));\n    yield takeEvery(RANGER_USER_ORDER_UPDATE, dispatchCurrentMarketOrderUpdates);\n    yield takeEvery(RANGER_USER_ORDER_UPDATE, dispatchOrderHistoryUpdates);\n\n    while (true) {\n        const { connectFetch, disconnectData } = yield race({\n            connectFetch: take(RANGER_CONNECT_FETCH),\n            disconnectData: take(RANGER_DISCONNECT_DATA),\n        });\n        let market: Market | undefined;\n\n        if (connectFetch) {\n            if (initialized) {\n                yield put(rangerDisconnectFetch());\n                yield take(RANGER_DISCONNECT_DATA);\n            }\n            connectFetchPayload = connectFetch.payload;\n        }\n\n        if (disconnectData) {\n            yield delay(1000);\n        }\n\n        try {\n            market = yield select(selectCurrentMarket);\n        } catch (error) {\n            market = undefined;\n        }\n\n        if (connectFetchPayload) {\n            const prevSubs = yield getSubscriptions();\n            const [channel, socket] = yield call(initRanger, connectFetchPayload, market, prevSubs, buffer);\n            initialized = true;\n            if (pipes) {\n                yield cancel(pipes);\n            }\n            pipes = yield fork(bindSocket, channel, socket, buffer);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}