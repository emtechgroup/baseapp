{"ast":null,"code":"'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\nvar ENABLE_SIGHASH_FORKID = true;\n\nvar sighashForForkId = function sighashForForkId(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(satoshisBN instanceof BN, 'For ForkId=0 signatures, satoshis or complete input must be provided');\n\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  }\n\n  ;\n\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter();\n\n    _.each(tx.inputs, function (input) {\n      writer.writeReverse(input.prevTxId);\n      writer.writeUInt32LE(input.outputIndex);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter();\n\n    _.each(tx.inputs, function (input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter();\n\n    if (_.isUndefined(n)) {\n      _.each(tx.outputs, function (output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n\n  function getHash(w) {\n    var buf = w.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n\n  ;\n  var writer = new BufferWriter(); // Version\n\n  writer.writeInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n  writer.write(hashPrevouts);\n  writer.write(hashSequence); //  outpoint (32-byte hash + 4-byte little endian)\n\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex); // scriptCode of the input (serialized as scripts inside CTxOuts)\n\n  writer.writeUInt8(subscript.toBuffer().length);\n  writer.write(subscript.toBuffer()); // value of the output spent by this input (8-byte little endian)\n\n  writer.writeUInt64LEBN(satoshisBN); // nSequence of the input (4-byte little endian) \n\n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n  writer.write(hashOutputs); // Locktime\n\n  writer.writeUInt32LE(transaction.nLockTime); // sighashType \n\n  writer.writeUInt32LE(sighashType >>> 0);\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} sed in ForkId signatures. If not provided, outputs's amount is used.\n *\n */\n\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var Transaction = require('./transaction');\n\n  var Input = require('./input'); // Copy transaction\n\n\n  var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n  subscript = new Script(subscript);\n\n  if (sighashType & Signature.SIGHASH_FORKID && ENABLE_SIGHASH_FORKID) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  } // For no ForkId sighash, separators need to be removed.\n\n\n  subscript.removeCodeseparators();\n  var i;\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN);\n  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"sources":["/Users/anthonypafundi/Desktop/baseapp/node_modules/bitcoincashjs/src/transaction/sighash.js"],"names":["buffer","require","Signature","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","BufferUtil","_","SIGHASH_SINGLE_BUG","BITS_64_ON","ENABLE_SIGHASH_FORKID","sighashForForkId","transaction","sighashType","inputNumber","subscript","satoshisBN","input","inputs","checkArgument","GetForkId","GetPrevoutHash","tx","writer","each","writeReverse","prevTxId","writeUInt32LE","outputIndex","buf","toBuffer","ret","sha256sha256","GetSequenceHash","sequenceNumber","GetOutputsHash","n","isUndefined","outputs","output","toBufferWriter","hashPrevouts","emptyBuffer","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","length","getHash","w","readReverse","writeInt32LE","version","write","writeUInt8","writeUInt64LEBN","nLockTime","sighash","Transaction","Input","txcopy","shallowCopy","SIGHASH_FORKID","removeCodeseparators","i","setScript","empty","Buffer","satoshis","fromBuffer","script","sign","privateKey","inputIndex","hashbuf","sig","set","nhashtype","verify","signature","publicKey","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n\nvar ENABLE_SIGHASH_FORKID = true;\n\n\nvar sighashForForkId = function(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(\n    satoshisBN instanceof BN, \n    'For ForkId=0 signatures, satoshis or complete input must be provided'\n  );\n\n  \n\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  };\n\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter()\n\n    _.each(tx.inputs, function(input) {\n        writer.writeReverse(input.prevTxId);\n        writer.writeUInt32LE(input.outputIndex);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter()\n\n    _.each(tx.inputs, function(input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter()\n\n    if ( _.isUndefined(n)) {\n      _.each(tx.outputs, function(output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n   \n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n    (sighashType & 31) != Signature.SIGHASH_SINGLE &&\n    (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n\n\nfunction getHash (w) {\n\n  var buf = w.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};  \n\n\n\n  var writer = new BufferWriter()\n\n  // Version\n  writer.writeInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  //  outpoint (32-byte hash + 4-byte little endian)\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex);\n\n  // scriptCode of the input (serialized as scripts inside CTxOuts)\n  writer.writeUInt8(subscript.toBuffer().length)\n  writer.write(subscript.toBuffer());\n\n  // value of the output spent by this input (8-byte little endian)\n  writer.writeUInt64LEBN(satoshisBN);\n  \n  // nSequence of the input (4-byte little endian) \n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // sighashType \n  writer.writeUInt32LE(sighashType >>>0);\n\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n}\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} sed in ForkId signatures. If not provided, outputs's amount is used.\n *\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n\n\n  if ( ( sighashType & Signature.SIGHASH_FORKID) && ENABLE_SIGHASH_FORKID) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  }\n\n  // For no ForkId sighash, separators need to be removed.\n  subscript.removeCodeseparators();\n\n  var i;\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN);\n  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"]},"metadata":{},"sourceType":"script"}